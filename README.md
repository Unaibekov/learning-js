# learning-js 



Подключение внешнего скрипта 
---

    <script src="/path/to/script.js"></script>


Подключение скрипта по URL 
---
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>

Вызов **alert**
---
    alert(выражение)
    alert('строка')

***Use strict*** нифига не понял
---

Переменные
---
    let message 
    message = 'Hello'
    alert(message) | Показывает содержимое переменной

    let message = 'Hello' | Присвоение значения переменной

    let user = 'John',
        age = 25
        message = 'Hello'

    /задачка с переменными/

    let admin, name
    admin = name
    name = 'John'

Константы 
---
    const myName = 'Vasya'
    myName = 'Fedya' | Константу переписывать нельзя!

Типы данных
---
>Число

    Операции с числами - *, /, +, - 

    Infinity - в результате деления на 0
    alert(1 / 0) = Infinity

    NaN - вычислительная ошибка, в результате неправильной математической операции 
    alert('не число' / 0) | Не число не делится

>Строка 

    let str = 'Привет'
    let phrase = `Обратные кавычки позволяют вставлять переменные ${name}`

    let name = 'Иван'
    alert(`Привет ${name}!`) | Реззультат - Привет, Иван!

>Булевой тип

    Принимает два значения: true(да) и false(нет)

    let nameFieldchecked = true | Да, поле отмечено
    let ageFieldChecked = false | Нет, поле не отмечено

>Null 

    Содержит только одно значение Null - ничего, пусто, неизвестно

    let age = null

>Undefined 

    Означает - "Значение не присвоено"

    let x | Значение не присвоено
    alert(x) | Выведет "undefined"

    Значение undefined можно присвоить любой переменной

    let x = 123 
    123 = undefined 
    alert(x) | Выведет "undefined"

>Объекты и символы ? надо разобрать, не понял

>Typeof 

    Возвращает тип аргумента 

    let type = true 
    alert(type) | Выведет boolean

    number - для чисел
    string - для строк
    boolean - для true и false
    null - для неизвестных значений
    undefined - для неприсвоенных значений
    object - для более сложных структур данных
    symbol - для уникальных идентификаторов

    null возвращает object - это официальная ошибка

Преобразование типов
---

>Строковое преобразование

    let value = true
    alert(typeof value)     | boolean

    value = String(value)   | Теперь value эта строка "true" 

>Числовое преобразование

    let str = '123'
    let num = Number(str)   | становится числом 123
    alert(typeof num)       | number

    Применяется когда ожидается получение числа из текстовых полей

    let age = Number('строка вместо числа)
    alert(age) | NaN, преобразование не удалось

Правила численного преобразования

    undefined   - NaN
    null        - 0
    true/false  - 1/0
    string      - Пробелы по краям обрезаются. Далее если пустая строка то 0. При ошибке результат NaN

    Пример 

    alert(Number(' 123 '))  | 123
    alert(Number('123z'))   | NaN Ошибка чтения числа в "z"
    alert(Number(true))     | 1
    alert(Number(false))    | 0

>Логическое преобразование

    - Пустые значение - 0, пустые строки, null, undefined и NaN - становятся FALSE

    - Все остальные значения становятся TRUE

    alert(Boolean(1))           | true
    alert(Boolean(0))           | false

    alert(Boolean('Привет'))    | true
    alert(Boolean(''))          | false

    Строка с нулем или с пробелом - всегда true
    alert(Boolean('0'))         | true
    alert(Boolean(' '))         | true

Операторы
---

>Термины: унитарный, бинарный, оеранд

Операнд - то, к чему применяется оператор. Например 5 * 2. 5 и 2 являются операндами

    let x = 1
    x = -x
    alert(x) | -1, применили "унарный минус", знак числа изменился на противоположный - "унарное отрицание"

    let x = 1, y = 3
    alert(y - x) | 2, применили "бинарный минус", применяется к двум операндам

> Сложение строк, ***бинарный +***

    Обычно "плюс" складывает числа, но если "бинарный плюс" применить к строкам, то они объединяются в одну

    let s = "моя" + "строка"
    alert(s) | моя строка

    let s = "моя" + " " + "строка"
    alert(s) | моя строка

    alert('1' + 2) | 12
    alert(2 + '1') | 21
    
>Преобразование к числу, ***унарный плюс***

    унарный плюс ничего не делает с числами, но если операнд не число, то унарный плюс преобразует его в число. Это тоже самое, что Number(...), но короче

    let x = 1
    alert(+x) | 1

    let y = -2
    alert(+y) | -2

    alert(+true)    | 1
    alert(+'')      | 0

    let apple = '2'
    let orange = '3'
    alert(apple + orange)   | 23, т.к. унарный + складывает строки
    alert(+apple + +orange) | 5, т.к. оба операнда преобразованы в числа

>Присваивание

    У оператора присвание "=" самый низкий приоритет, поэтому когда переменной что-либо присваивают, то сначала выполнится арифметика
    
    let x = 2 * 2 + 1 
    alert(x) | 5

    Возможно присваивание по цепочке 

    let a, b, c 
    a = b = c = 2 + 2 
    alert( a ) | 4
    alert( b ) | 4
    alert( c ) | 4

>Остаток от деления 

    alert(5 % 2) | остаток 1 (5-2=2 2-2= 1)
    alert(8 % 3) | остаток 2 (8-3=5 5-3=2)
    alert(6 % 3) | остаток 0 (6-3=3 3-3=0)

>Возведение в степень

    alert(2 ** 2) | 4 (2*2)
    alert(2 ** 3) | 8 (2*2*2)
    alert(2 ** 4) | 16 (2*2*2*2)

>Инкремент/декремент - разобрать позже

    Увеличение или уменьшение переменной на единицу. Применить его можно только к переменной. 

    Инкремент ++ увеличивает на 1
    let counter = 2
    counter++
    alert(counter) | 3

    Декремент -- уменьшает на 1
    let counter = 2
    counter--
    alert(counter) | 1

    «Постфиксная форма» - это когда оператор идёт после переменной: counter++.
    
    «Префиксная форма» – это когда оператор идёт перед переменной: ++counter.

>Побитовые операторы - разобрать позже

>Сокращенная арифметика с присваиванием 

    let n = 2
    n = n + 5
    n = n * 2
    
    сокращенная запись

    let n = 2 
    n += 5      | n = 5 + 2 = 7
    n *= 2      | n = 7 * 2 = 14

    Краткая форма действует и на /=, -= и так далее

    let n = 2 
    n *= 3 + 5
    alert(n) | 16 - сначала правая часть (3 + 5 = 8) потом присваивание по приоритету (= самый низкий приоритет)

>Оператор запятая

    Оператор "," самый необычный и используется редко.

    Вычисляет несколько выражений, но возвращает результат только последнего

    let = a (1 + 2, 3 + 4)
    alert(a) | 7 (3 + 4), первое выражение выполняется, но отбрасывается

    Приоритет "," ниже "="

Опеарторы сравнения
---

    Больше/меньше: a > b, a < b
    Больше/меньше или равно: a >= b, a <= b
    Равно: a==b. Один знак "=" означает присваивание 
    Не равно записывается как !=

>Результат сравнения имеет логический смысл

    alert(2 > 1)    | true
    alert(2 == 1)   | false
    alert(2 != 1)   | true

>Сравнение строк

    Используется алфавитный или лексикографический порядок

    alert('Я' > 'А')          | true
    alert('Кот' > 'Код')      | true
    alert('Сонный' > 'Сон')   | true

>Сравнение разных типов
 
    alert('2' > 1)      | true, строка "2" становится числом 2 
    alert('01' == 1)    | true, строка "01" стновится числом 1

>Строгое сравнение 

    Проверяет равенство без приведения типов

    alert( 0 === false ) | false, т.к. сравниваются разные типы
